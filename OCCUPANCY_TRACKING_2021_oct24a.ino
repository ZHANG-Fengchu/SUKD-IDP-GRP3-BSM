#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "OCCUPANCY_TRACKING_2021"
  https://create.arduino.cc/cloud/things/97ba9a30-6cd8-4c59-948b-6778254ef920

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float iotBusvoltage;
  float iotCurrent_mA;
  float iotLoadvoltage;
  float iotPower_mW;
  float iotShuntvoltage;
  int maxNumOfPpl;
  int numOfPpl;
  bool beacon;
  bool beaconKillSwitch;
  bool numOfPplRst;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"  

// MANUAL CODE BEGIN 
// {
// TM1637 display
#include <Arduino.h>
#include <TM1637Display.h>
// Module connection pins (Digital Pins)
#define CLK 9
#define DIO 10
TM1637Display display(CLK, DIO);

// INA219 Stuff
#include <Wire.h>
#include <Adafruit_INA219.h>

Adafruit_INA219 ina219;

// constants won't change. They're used here to set pin numbers:
const int buttonPinAdd = 12;     // the number of the pushbutton pin
const int ledPinAdd =  2;      // the number of the LED pin
const int buttonPinMin = 11;     
const int ledPinMin =  3; 
const int beaconPin = 21;

// variables will change:
int buttonStateAdd = 0;         // variable for reading the pushbutton status  
int lastButtonStateAdd = 0; 
int buttonStateMin = 0;         
int lastButtonStateMin = 0; 
//int buttonPushCounter = 0;

// } 
// MANUAL CODE END   


void setup(void) 
{
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
  // MANUAL CODE BEGIN  
  // {
  // initialize the LED pin as an output:
  pinMode(ledPinAdd, OUTPUT);
  pinMode(ledPinMin, OUTPUT);
  pinMode(beaconPin, OUTPUT);

  // initialize the pushbutton pin as an input:
  pinMode(buttonPinAdd, INPUT_PULLUP);
  pinMode(buttonPinMin, INPUT_PULLUP);
  
  // TM1637 stuff

  
  //INA219 Stuff
    //{
  //Serial.begin(115200);
  
  /*
  while (!Serial) 
  {
      // will pause Zero, Leonardo, etc until serial console opens
      delay(1);
  }
  */

  uint32_t currentFrequency;
    
  /*Serial.println("Hello!");*/
  
  // Initialize the INA219.
  // By default the initialization will use the largest range (32V, 2A).  However
  // you can call a setCalibration function to change this range (see comments).
  
  
  if (! ina219.begin()) 
  {
    Serial.println("Failed to find INA219 chip");
    while (1) { delay(10); }
  }
  
  
  // To use a slightly lower 32V, 1A range (higher precision on amps):
  //ina219.setCalibration_32V_1A();
  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):
  //ina219.setCalibration_16V_400mA();

  /*Serial.println("Measuring voltage and current with INA219 ...");*/
    // }
  // } 
  // MANUAL CODE END   
  
}

void loop(void) 
{
  ArduinoCloud.update();
  // Your code here
  
  // MANUAL CODE BEGIN    
  // {
  
  //INA219 Stuff
    //{
  /*
  float shuntvoltage = 0;
  float busvoltage = 0;
  float current_mA = 0;
  float loadvoltage = 0;
  float power_mW = 0;
  */

  iotShuntvoltage = ina219.getShuntVoltage_mV();
  iotBusvoltage = ina219.getBusVoltage_V();
  iotCurrent_mA = ina219.getCurrent_mA();
  iotPower_mW = ina219.getPower_mW();
  iotLoadvoltage = iotBusvoltage + (iotShuntvoltage / 1000);
  
  /*
  iotShuntvoltage = shuntvoltage;
  iotBusvoltage = busvoltage;
  iotCurrent_mA = current_mA;
  iotPower_mW = power_mW;
  iotLoadvoltage = loadvoltage;
  */

  /*
  Serial.print("Bus Voltage:   "); Serial.print(iotBusvoltage); Serial.println(" V");
  Serial.print("Shunt Voltage: "); Serial.print(iotShuntvoltage); Serial.println(" mV");
  Serial.print("Load Voltage:  "); Serial.print(iotLoadvoltage); Serial.println(" V");
  Serial.print("Current:       "); Serial.print(iotCurrent_mA); Serial.println(" mA");
  Serial.print("Power:         "); Serial.print(iotPower_mW); Serial.println(" mW");
  Serial.println("");
  */
    //}
  
  // read the state of the pushbutton value:
  buttonStateAdd = digitalRead(buttonPinAdd);
  buttonStateMin = digitalRead(buttonPinMin);
  digitalWrite(beaconPin, beacon);

  // Check whether numOfPplRst button is pushed. 
  if (numOfPplRst == true)
  {
    numOfPpl = 0; 
  }
  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:
  if (buttonStateAdd == LOW) 
  {
    // turn LED on:
    digitalWrite(ledPinAdd, HIGH);
    if (buttonStateAdd != lastButtonStateAdd)
    {
      //buttonPushCounter ++ ;
      numOfPpl ++ ;
    }
  } 
  else 
  {
    // turn LED off:
    digitalWrite(ledPinAdd, LOW);
  }
  lastButtonStateAdd = buttonStateAdd;
  
  
  if (buttonStateMin == LOW) 
  {
    // turn LED on:
    digitalWrite(ledPinMin, HIGH);
    if (buttonStateMin != lastButtonStateMin)
    {
      //buttonPushCounter -- ;
      if (numOfPpl > 0)
      {  
        numOfPpl -- ;
      }
    }
  } 
  else 
  {
    // turn LED off:
    digitalWrite(ledPinMin, LOW);
  }
  
  lastButtonStateMin = buttonStateMin;
  
  if (beaconKillSwitch == true)
  {
    if (numOfPpl > maxNumOfPpl)
    {
      beacon = true;
    }
    else
    {
      beacon = false; 
    }
  }
  else
  {
    beacon = false;
  }
  //TM1637 stuff
  display.setBrightness(0x0f);
  display.showNumberDec(numOfPpl, true);

  delay(100);
  // } 
  // MANUAL CODE END   
}

// MANUAL CODE BEGIN 
// {

// } 
// MANUAL CODE END   

/*
  Since NumOfPpl is READ_WRITE variable, onNumOfPplChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onNumOfPplChange()  
{
  // Add your code here to act upon NumOfPpl change
  // { MANUAL CODE BEGIN    
  //numOfPpl = buttonPushCounter ;
  // } MANUAL CODE END  
}

/*
  Since Beacon is READ_WRITE variable, onBeaconChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBeaconChange()  {
  // Add your code here to act upon Beacon change
}


/*
  Since MaxNumOfPpl is READ_WRITE variable, onMaxNumOfPplChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMaxNumOfPplChange()  {
  // Add your code here to act upon MaxNumOfPpl change
}


/*
  Since BeaconKillSwitch is READ_WRITE variable, onBeaconKillSwitchChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBeaconKillSwitchChange()  {
  // Add your code here to act upon BeaconKillSwitch change
}

/*
  Since NumOfPplRst is READ_WRITE variable, onNumOfPplRstChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onNumOfPplRstChange()  {
  // Add your code here to act upon NumOfPplRst change
}








